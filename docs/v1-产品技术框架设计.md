# MGIT v1 - 产品技术框架设计

## 1. 程序整体框架设计

### 1.1 架构模式
MGIT采用Rust工作空间（Workspace）架构模式，将项目拆分为三个独立但协同工作的crate：

- **core crate**：核心业务逻辑库，提供Git操作API和共享功能
- **cli crate**：命令行界面应用，作为主要用户入口
- **gui crate**：图形用户界面应用，提供直观的桌面操作体验

### 1.2 分层架构
```
┌─────────────────────────────────────┐
│             CLI/GUI层               │
│         (命令解析/用户交互)          │
├─────────────────────────────────────┤
│             业务逻辑层               │
│         (多仓库管理/并发处理)        │
├─────────────────────────────────────┤
│             核心操作层               │
│         (Git命令封装/配置管理)       │
├─────────────────────────────────────┤
│             基础设施层               │
│         (外部命令执行/错误处理)       │
└─────────────────────────────────────┘
```

### 1.3 数据流设计
1. **配置加载**：TOML配置文件 → 内存结构体
2. **并发调度**：仓库列表 → Rayon线程池 → 并行执行
3. **状态跟踪**：操作进度 → Progress trait → 用户反馈
4. **结果汇总**：各仓库结果 → 聚合报告 → 输出展示

## 2. 模块设计

### 2.1 Core模块架构

#### 2.1.1 Git操作模块 (`core/src/core/git.rs`)
**职责**：封装所有Git相关操作，统一错误处理
**关键函数**：
```rust
// 仓库状态检查
pub fn is_repository(path: impl AsRef<Path>) -> Result<(), anyhow::Error>

// 分支管理
pub fn get_current_branch(path: impl AsRef<Path>) -> Result<String, anyhow::Error>
pub fn checkout(path: impl AsRef<Path>, args: &[&str]) -> anyhow::Result<()>

// 远程操作
pub fn add_remote_url(path: impl AsRef<Path>, url: impl AsRef<str>) -> anyhow::Result<()>
pub fn find_remote_url_by_name(path: impl AsRef<Path>, name: impl AsRef<str>) -> Result<String, anyhow::Error>

// 提交操作
pub fn get_current_commit(path: impl AsRef<Path>) -> Result<String, anyhow::Error>
pub fn reset(path: impl AsRef<Path>, reset_type: impl AsRef<str>, remote_ref: impl AsRef<str>) -> anyhow::Result<()>
```

**设计模式**：命令模式，每个Git操作封装为独立函数，便于测试和扩展。

#### 2.1.2 仓库管理模块 (`core/src/core/repo.rs`)
**核心结构体**：
```rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
#[serde(rename_all = "kebab-case")]
pub struct TomlRepo {
    pub local: Option<String>,      // 本地路径
    pub remote: Option<String>,     // 远程URL
    pub branch: Option<String>,     // 分支名
    pub tag: Option<String>,        // 标签
    pub commit: Option<String>,     // 提交Hash
    pub sparse: Option<Vec<String>>, // 稀疏检出路径
}

#[derive(Debug, Clone)]
pub struct RepoInfo {
    pub name: String,
    pub path: PathBuf,
    pub remote_url: Option<String>,
}
```

**职责**：
- TOML配置解析与验证
- 仓库状态同步逻辑
- 依赖关系管理

#### 2.1.3 并发处理模块 (`core/src/ops/`)
**核心特性**：
- Rayon并行执行框架
- 可配置线程池大小
- 进度报告机制

**关键操作**：
- `sync.rs`：仓库同步（fetch + reset）
- `fetch.rs`：远程更新
- `clean.rs`：工作目录清理
- `snapshot.rs`：状态快照

### 2.2 CLI模块架构 (`cli/src/`)
**命令行框架**：基于clap 4.0.8的派生宏设计
```rust
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand)]
pub enum Commands {
    Sync(SyncCommand),
    Fetch(FetchCommand),
    Clean(CleanCommand),
    // ... 其他子命令
}
```

**命令模式**：每个子命令实现`CliCommand` trait：
```rust
pub trait CliCommand {
    fn exec(self) -> MgitResult;
}
```

### 2.3 GUI模块架构 (`gui/src/`)
**技术栈**：egui immediate mode + eframe
**架构模式**：
- **App结构体**：实现`eframe::App` trait
- **组件化设计**：分离widgets、editors、utils
- **状态管理**：内存状态 + 持久化存储

**关键组件**：
- `editor.rs`：主编辑器界面
- `repositories.rs`：仓库管理面板
- `quick_bar.rs`：快速操作栏
- `settings.rs`：配置管理界面

## 3. 技术选项与选型

### 3.1 编程语言：Rust 1.76.0+
**选型理由**：
- **内存安全**：所有权系统杜绝内存错误
- **性能**：零成本抽象，原生编译速度
- **跨平台**：统一代码库支持Windows/Linux/macOS
- **生态成熟**：丰富的crates生态系统

### 3.2 GUI框架：egui 0.19.0
**选型理由**：
- **Immediate Mode**：简化状态管理，无需事件循环
- **跨平台**：原生渲染，支持多平台部署
- **轻量级**：单二进制文件，无额外依赖
- **Rust原生**：完全用Rust编写，类型安全

### 3.3 Git操作策略：外部命令执行
**设计决策**：
```rust
pub fn exec_cmd(path: impl AsRef<Path>, cmd: &str, args: &[&str]) -> Result<String, anyhow::Error> {
    let mut command = std::process::Command::new(cmd);
    command.current_dir(path).args(args);
    // Windows特殊处理
    #[cfg(target_os = "windows")]
    {
        use std::os::windows::process::CommandExt;
        command.creation_flags(CREATE_NO_WINDOW);
    }
    let output = command.output()?;
    // 错误处理与输出解析
}
```

**优势**：
- **兼容性**：利用系统Git，无版本依赖问题
- **安全性**：避免libgit2的复杂安全问题
- **灵活性**：可使用所有Git命令和选项

### 3.4 并发处理：Rayon 1.5
**并行策略**：
- **仓库级并行**：每个仓库独立线程
- **线程池管理**：可配置并发数量
- **资源控制**：避免过度并发导致网络拥塞

### 3.5 配置格式：TOML
**结构体定义**：
```rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
#[serde(rename_all = "kebab-case")]
pub struct TomlSettings {
    pub repos: Vec<TomlRepo>,
    pub settings: Option<Settings>,
}
```

**优势**：
- **可读性强**：人类友好的配置语法
- **类型安全**：serde自动序列化/反序列化
- **版本兼容**：toml_edit支持增量修改

## 4. 核心算法与实现

### 4.1 多仓库并发同步算法
**算法流程**：
1. **配置解析**：读取TOML配置，构建仓库列表
2. **依赖排序**：根据仓库依赖关系拓扑排序
3. **并行执行**：
   ```rust
   repos.par_iter().for_each(|repo| {
       // 每个仓库独立处理
       sync_single_repo(repo, progress);
   });
   ```
4. **进度聚合**：收集各仓库执行结果
5. **错误处理**：隔离失败仓库，不影响其他仓库

**优化策略**：
- **批处理**：分组执行减少网络连接开销
- **缓存机制**：避免重复的网络请求
- **重试逻辑**：网络失败自动重试

### 4.2 Git操作封装算法
**统一接口设计**：
```rust
pub fn exec_cmd_with_progress(
    repo_info: &RepoInfo,
    command: &mut Command,
    progress: &impl Progress,
) -> anyhow::Result<()> {
    // 启动进程
    let mut spawned = command.spawn()?;
    
    // 实时进度报告
    if let Some(stderr) = spawned.stderr {
        let lines = BufReader::new(stderr).split(b'\r');
        for line in lines {
            let progress_msg = parse_progress_line(line);
            progress.repo_info(repo_info, progress_msg);
        }
    }
    
    // 等待完成并检查状态
    let exit_status = spawned.wait()?;
    if !exit_status.success() {
        return Err(process_error(exit_status));
    }
    
    Ok(())
}
```

**错误处理算法**：
- **分层错误**：基础设施错误 → Git错误 → 业务错误
- **上下文保留**：错误链包含完整调用栈
- **恢复策略**：stash保护本地修改，失败时可回滚

### 4.3 配置文件版本兼容算法
**向后兼容策略**：
```rust
impl TomlRepo {
    pub fn from_toml(value: &toml::Value) -> Result<Self, anyhow::Error> {
        // 字段存在性检查
        let local = value.get("local").and_then(|v| v.as_str());
        let remote = value.get("remote").and_then(|v| v.as_str());
        // 支持旧版本字段名
        let branch = value.get("branch")
            .or_else(|| value.get("default-branch"))
            .and_then(|v| v.as_str());
        
        Ok(TomlRepo {
            local: local.map(|s| s.to_string()),
            remote: remote.map(|s| s.to_string()),
            branch: branch.map(|s| s.to_string()),
            // 其他字段类似处理
        })
    }
}
```

## 5. 性能优化策略

### 5.1 内存优化
- **零拷贝设计**：PathBuf和String避免不必要的克隆
- **流式处理**：大文件操作使用流式API
- **资源池**：复用Command实例减少分配

### 5.2 网络优化
- **并发限制**：避免网络拥塞的指数退避算法
- **连接复用**：SSH连接保持和复用
- **增量更新**：智能判断是否需要全量同步

### 5.3 CPU优化
- **SIMD加速**：字符串处理使用向量化指令
- **异步I/O**：非阻塞文件操作
- **编译优化**：`opt-level = 'z'` 和 LTO

## 6. 安全设计

### 6.1 权限模型
**最小权限原则**：
- 仅访问配置中指定的仓库路径
- 继承用户现有Git权限，无需额外认证
- 本地修改保护（stash机制）

### 6.2 输入验证
**配置安全**：
```rust
pub fn validate_config(config: &TomlSettings) -> Result<(), ValidationError> {
    for repo in &config.repos {
        // 路径安全检查
        if !is_safe_path(&repo.local) {
            return Err(ValidationError::UnsafePath);
        }
        // URL格式验证
        if let Some(remote) = &repo.remote {
            if !is_valid_git_url(remote) {
                return Err(ValidationError::InvalidUrl);
            }
        }
    }
    Ok(())
}
```

### 6.3 错误隔离
- **沙箱执行**：每个仓库操作独立进程
- **资源限制**：CPU时间和内存使用限制
- **审计日志**：所有操作记录用于安全审计

## 7. 测试策略

### 7.1 单元测试
**核心模块测试**：
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_git_operations() {
        let temp_dir = TempDir::new().unwrap();
        // 设置测试仓库
        // 执行操作
        // 断言结果
    }
}
```

### 7.2 集成测试
- **Docker环境**：使用gitea-compose进行端到端测试
- **多平台测试**：GitHub Actions CI/CD矩阵
- **性能基准**：criterion.rs进行性能回归测试

### 7.3 模糊测试
- **配置解析**：任意TOML输入的健壮性测试
- **路径处理**：恶意路径字符串的安全测试

## 8. 部署与分发

### 8.1 编译配置
**Cargo.toml优化**：
```toml
[profile.release]
opt-level = 'z'      # 最大优化
lto = true           # 链接时优化
codegen-units = 1    # 单代码生成单元
strip = true         # 去除调试符号
```

### 8.2 跨平台构建
**GitHub Actions矩阵**：
- **目标平台**：x86_64-pc-windows-msvc, x86_64-unknown-linux-gnu, x86_64-apple-darwin, aarch64-apple-darwin
- **依赖管理**：使用cross.rs进行交叉编译
- **静态链接**：musl libc避免glibc版本依赖

### 8.3 安装包制作
- **Windows**：MSI安装包 + winget分发
- **macOS**：DMG镜像 + Homebrew cask
- **Linux**：AppImage + deb/rpm包

## 9. 扩展性设计

### 9.1 插件架构
**扩展点**：
- **操作插件**：自定义Git操作流程
- **配置插件**：支持新的配置格式
- **UI插件**：自定义GUI组件

### 9.2 API设计
**公开接口**：
```rust
pub trait GitOperation {
    fn execute(&self, repo: &RepoInfo, progress: &impl Progress) -> anyhow::Result<OperationResult>;
}

pub trait ConfigProvider {
    fn load_config(&self, path: &Path) -> anyhow::Result<TomlSettings>;
    fn save_config(&self, config: &TomlSettings, path: &Path) -> anyhow::Result<()>;
}
```

### 9.3 协议扩展
- **支持新Git托管服务**：GitLab, Bitbucket等
- **自定义同步策略**：增量同步、选择性同步等
- **集成CI/CD**：与Jenkins, GitHub Actions集成

这个设计文档基于当前代码库的实际实现，体现了MGIT项目的成熟架构设计和工程实践。整个系统在保证高性能、可靠性和安全性的同时，保持了良好的可维护性和扩展性。