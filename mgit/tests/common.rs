use mgit::utils::progress::{Progress, RepoInfo};
use mgit::utils::style_message::StyleMessage;
use std::path::Path;
use std::process::Stdio;

use tempfile::TempDir;

#[allow(unused)]
pub const DEFAULT_BRANCH: &str = "master";

#[allow(unused)]
pub const MGIT_REPO: &str = if cfg!(feature = "use_gitea") {
    "http://localhost:3000/mgit/mgit.git"
} else {
    "https://github.com/funny/mgit.git"
};

#[allow(unused)]
pub const IMGUI_REPO: &str = if cfg!(feature = "use_gitea") {
    "http://localhost:3000/mgit/imgui-rs.git"
} else {
    "https://github.com/imgui-rs/imgui-rs.git"
};

#[allow(unused)]
pub const SBERT_REPO: &str = if cfg!(feature = "use_gitea") {
    "http://localhost:3000/mgit/rust-sbert.git"
} else {
    "https://gitee.com/icze1i0n/rust-sbert.git"
};

#[allow(unused)]
pub const CSBOOKS_REPO: &str = if cfg!(feature = "use_gitea") {
    "http://localhost:3000/mgit/CS-Books.git"
} else {
    "https://gitee.com/ForthEspada/CS-Books.git"
};

#[allow(unused)]
pub mod failed_message {
    pub const GIT_INIT: &str = "git init failed";
    pub const GIT_ADD_REMOTE: &str = "git add remote failed";
    pub const GIT_STAGE: &str = "git stage failed";
    pub const GIT_COMMIT: &str = "git commit failed";
    pub const GIT_STATUS: &str = "git status failed";
    pub const GIT_CHECKOUT: &str = "git checkout failed";
    pub const GIT_RESET: &str = "git reset failed";
    pub const GIT_STASH_LIST: &str = "git stash list failed";
    pub const GIT_STASH_POP: &str = "git stash pop failed";
    pub const GIT_BRANCH: &str = "git branch failed";
    pub const GIT_FETCH: &str = "git fetch failed";
    pub const GIT_CONFIG: &str = "git config failed";
    pub const GIT_REV_LIST: &str = "git rev-list failed";
    pub const GIT_SPARSE_CHECKOUT: &str = "git sparse-checkout failed";

    pub const WRITE_FILE: &str = "write file failed";
}

pub fn exec_cmd(path: impl AsRef<Path>, cmd: &str, args: &[&str]) -> Result<String, anyhow::Error> {
    let output = std::process::Command::new(cmd)
        .current_dir(path.as_ref())
        .args(args)
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .output()?;
    let stdout = String::from_utf8(output.stdout)?;
    let stderr = String::from_utf8(output.stderr)?;

    match output.status.success() {
        false => Err(anyhow::anyhow!(stderr)),
        true => Ok(stdout),
    }
}

pub fn create_test_dir(prefix: &str) -> TempDir {
    let mut builder = tempfile::Builder::new();
    builder.prefix(prefix);

    // Try to find the workspace root's target directory
    // This assumes we are running tests from within the workspace structure
    // d:\ai-projects\mgit\mgit-core\tests\common.rs -> d:\ai-projects\mgit\target\tmp
    // Walk up until we find Cargo.toml of the workspace or just go up a few levels
    // Heuristic: If we are in mgit-core, we want ../target/tmp

    // Let's try to use a fixed relative path from the manifest dir if available
    if let Ok(manifest_dir) = std::env::var("CARGO_MANIFEST_DIR") {
        let manifest_path = std::path::PathBuf::from(manifest_dir);
        let tmp_path = manifest_path.parent().unwrap().join("target").join("tmp");
        if !tmp_path.exists() {
            let _ = std::fs::create_dir_all(&tmp_path);
        }
        if tmp_path.exists() {
            builder
                .tempdir_in(tmp_path)
                .expect("create temp dir failed")
        } else {
            builder.tempdir().expect("create temp dir failed")
        }
    } else {
        builder.tempdir().expect("create temp dir failed")
    }
}

#[allow(dead_code)]
pub fn mgit_repo() -> &'static str {
    match use_gitea() {
        true => "http://localhost:3000/mgit/mgit.git",
        false => "https://github.com/funny/mgit.git",
    }
}
#[allow(dead_code)]
pub fn imgui_repo() -> &'static str {
    match use_gitea() {
        true => "http://localhost:3000/mgit/imgui-rs.git",
        false => "https://github.com/imgui-rs/imgui-rs.git",
    }
}
#[allow(dead_code)]
pub fn sbert_repo() -> &'static str {
    match use_gitea() {
        true => "http://localhost:3000/mgit/rust-sbert.git",
        false => "https://gitee.com/icze1i0n/rust-sbert.git",
    }
}
#[allow(dead_code)]
pub fn csbooks_repo() -> &'static str {
    match use_gitea() {
        true => "http://localhost:3000/mgit/CS-Books.git",
        false => "https://gitee.com/ForthEspada/CS-Books.git",
    }
}

pub struct TomlBuilder {
    toml_string: String,
}

impl Default for TomlBuilder {
    fn default() -> Self {
        TomlBuilder {
            toml_string:
                "# This file is automatically @generated by mgit.\n# Editing it as you wish.\n"
                    .to_string(),
        }
    }
}

impl TomlBuilder {
    pub fn build(self) -> String {
        self.toml_string
    }

    pub fn default_branch(mut self, default_branch: impl AsRef<str>) -> Self {
        self.toml_string.push_str(&format!(
            "default-branch = \"{}\"\n",
            default_branch.as_ref()
        ));
        self
    }

    pub fn join_repo(
        mut self,
        local: &str,
        remote: &str,
        branch: Option<&str>,
        commit: Option<&str>,
        tag: Option<&str>,
    ) -> Self {
        self.toml_string
            .push_str(&format!("\n[[repos]]\nlocal = \"{}\"\n", local));
        self.toml_string
            .push_str(&format!("remote = \"{}\"\n", remote));
        if let Some(branch) = branch {
            self.toml_string
                .push_str(&format!("branch = \"{}\"\n", branch));
        }
        if let Some(commit) = commit {
            self.toml_string
                .push_str(&format!("commit = \"{}\"\n", commit));
        }
        if let Some(tag) = tag {
            self.toml_string.push_str(&format!("tag = \"{}\"\n", tag));
        }
        self
    }
}

#[allow(dead_code)]
fn use_gitea() -> bool {
    cfg!(feature = "use_gitea")
}

/// Helper function to setup git author identity for tests
#[allow(dead_code)]
pub fn check_git_author_identity(path: &std::path::PathBuf) {
    if exec_cmd(path, "git", &["config", "--global", "user.email"]).is_err() {
        exec_cmd(
            path,
            "git",
            &["config", "--global", "user.email", "foobar@xmfunny.com"],
        )
        .expect(failed_message::GIT_CONFIG);
        exec_cmd(path, "git", &["config", "--global", "user.name", "foobar"])
            .expect(failed_message::GIT_CONFIG);
    }
}

/// Helper function to write config file
#[allow(dead_code)]
pub fn write_config_file(path: &std::path::Path, content: &str) {
    std::fs::write(path, content.trim()).expect(failed_message::WRITE_FILE);
}

/// Helper function to create a test repository setup
#[allow(dead_code)]
pub struct TestRepoSetup {
    pub tmp_dir: TempDir,
    pub path: std::path::PathBuf,
    pub config_file: std::path::PathBuf,
}

impl TestRepoSetup {
    pub fn new(prefix: &str) -> Self {
        let tmp_dir = create_test_dir(prefix);
        let path = tmp_dir.path().to_path_buf();
        let config_file = path.join(".gitrepos");
        std::fs::create_dir_all(&path).expect("Failed to create test directory");
        Self {
            tmp_dir,
            path,
            config_file,
        }
    }

    pub fn input_path(&self) -> &str {
        self.path.to_str().unwrap()
    }
}

#[derive(Clone, Default)]
pub struct TestProgress;

#[allow(unused)]
impl Progress for TestProgress {
    fn on_batch_start(&self, _total: usize) {}

    fn on_batch_finish(&self) {}

    fn on_repo_start(&self, repo_info: &RepoInfo, message: StyleMessage) {}

    fn on_repo_update(&self, repo_info: &RepoInfo, message: StyleMessage) {}

    fn on_repo_success(&self, repo_info: &RepoInfo, message: StyleMessage) {}

    fn on_repo_error(&self, repo_info: &RepoInfo, message: StyleMessage) {}
}
