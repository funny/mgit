use serde::{Deserialize, Serialize};
use std::{fs, path::Path};

use crate::config::repo_config::RepoConfig;

/// Main configuration structure for MGIT
///
/// This structure represents the `.gitrepos` configuration file format.
#[derive(Serialize, Deserialize, Debug, Default)]
#[serde(rename_all = "kebab-case")]
pub struct MgitConfig {
    /// Version of the configuration file format
    pub version: Option<String>,
    /// Default branch name to use when not specified in repo config
    pub default_branch: Option<String>,
    /// Default remote name to use when not specified in repo config
    pub default_remote: Option<String>,
    /// List of repository configurations
    pub repos: Option<Vec<RepoConfig>>,
}

impl MgitConfig {
    /// Load configuration from a TOML file
    ///
    /// # Arguments
    ///
    /// * `path` - Path to the `.gitrepos` configuration file
    ///
    /// # Returns
    ///
    /// Returns `Some(MgitConfig)` if the file exists and can be parsed, `None` otherwise.
    pub fn load(path: impl AsRef<Path>) -> Option<Self> {
        if !path.as_ref().is_file() {
            return None;
        }

        let content = match fs::read_to_string(path.as_ref()) {
            Ok(c) => c.replace("\".\"", "\"\""),
            Err(_) => return None,
        };

        let Ok(mut toml_config) = toml::from_str::<MgitConfig>(&content) else {
            return None;
        };

        if let Some(item) = toml_config.repos.as_mut() {
            item.sort();
        }

        Some(toml_config)
    }

    /// Serialize configuration to TOML string format
    ///
    /// # Returns
    ///
    /// Returns a formatted TOML string representation of the configuration.
    pub fn serialize(&self) -> String {
        let toml_string = toml::to_string(self).unwrap_or_default();
        let mut out = String::new();

        out.push_str("# This file is automatically @generated by mgit.\n");
        out.push_str("# Editing it as you wish.\n");

        let Ok(doc) = toml_edit::ser::to_document(self) else {
            return toml_string;
        };

        let item = doc.as_item();

        let Some(table) = item.as_table() else {
            return toml_string;
        };

        if let Some(item) = table.get("version") {
            out.push_str(&format!("version = {}\n", item));
        }

        if let Some(item) = table.get("default-branch") {
            out.push_str(&format!("default-branch = {}\n", item));
        }

        if let Some(item) = table.get("default-remote") {
            out.push_str(&format!("default-remote = {}\n", item));
        }

        out.push('\n');

        if let Some(repos) = table.get("repos") {
            let Some(list) = repos.as_array() else {
                return toml_string;
            };

            for entry in list {
                out.push_str("[[repos]]\n");
                let Some(table) = entry.as_inline_table() else {
                    continue;
                };

                if let Some(item) = table.get("local") {
                    out.push_str(&format!("local = {}\n", item));
                }

                if let Some(item) = table.get("remote") {
                    out.push_str(&format!("remote = {}\n", item));
                }

                if let Some(item) = table.get("branch") {
                    out.push_str(&format!("branch = {}\n", item));
                }

                if let Some(item) = table.get("tag") {
                    out.push_str(&format!("tag = {}\n", item));
                }

                if let Some(item) = table.get("commit") {
                    out.push_str(&format!("commit = {}\n", item));
                }

                if let Some(item) = table.get("sparse") {
                    out.push_str(&format!("sparse = {}\n", item));
                }

                if let Some(item) = table.get("labels") {
                    out.push_str(&format!("labels = {}\n", item));
                }

                out.push('\n');
            }
        }

        out
    }
}
